= Inverser le contrôle avec StructueMap !
:hp-image: introduction-a-angular2.png
:published_at: 2015-11-26
:hp-tags: C#, IoC, StructureMap


L'inversion de contrôle (aka *IoC*) est un pattron d'architecture permettant de casser les adhérenses entre les dépendances. Ce découplage permet au dépendances de haut niveau de ne plus reposer directement sur celle de bas niveau et de passer par une couche d'abstration. L'objectif est d'améliorer la modularité des applications afin de faciliter les étapes de maintenance et d'évolution.


== Pourquoi ce pattern ?

Avant de montrer la mise en place de l'inversion de contrôle il est préférable d'expliquer comment on en est arrivé là !

Le problème de départ est assez simple en réalité. Si on a une application développée en couche et que l'ont fait reposer chaqu'une d'elle sur une autre de plus bas niveau, que va-t-il se passer si par la suite on veut changer, modifier, supprimer la couche la plus basse ? Le problème est là, il va falloir modifier la couche de plus haut niveau pour l'adapter en conséquence. Il est d'ailleurs fort probable que cela déclencher des modification en cascade sur toutes les couches haut niveau.

Avec l'inversion de contrôle on va plutôt faire reposer chaque couche sur une abstraction afin de passer de ça :

[Schéma]

A ça :

[Schéma]

La différence est suptile mais importante. Dans le second shémas, changer les couches concrêtes de mon application n'entraine pas de problèmes de structure, tout compilera. Mieux encore, le développement de l'application peut être abstrait et n'avoir aucunes connaissances du fonctionnement bas niveau. Plus fort, je peux définir des abstractions utilisés par les couches de bas niveau qui sont implémentées en haut niveau. Un autre intéressant, les test unitaires deviennent beaucoup plus simple et pertinent car les dépendances ne rentre plus en compte dans l'étape de validation.

Au final en utilisant l'inversion de contrôle, votre application va devenir plus modulaire, souple, maintenable, évolutive et testable.

NOTE: L'inversion de contrôle permet aussi de respecter un des principes majeurs de https://en.wikipedia.org/wiki/SOLID_(object-oriented_design)[SOLID] : l'inversion des dépendances. Ce principe définit qu'il faut toujours dépendre des abstractions et non des implémentations. Les principes SOLID sont considérer par beaucoup comme les _"Best Pratices"_ de la POO. Ils permettent d'avoir un développement éfficace et fiable.

Parmis les manières les plus courrante de mettre en place l'IoC, il existe :

* Le pattern https://en.wikipedia.org/wiki/Factory_(object-oriented_programming)[Factory] qui permet de délégué la création d'instance. Une approche rudimentaire mais qui a le mérite d'être simple dans sa mise en place.
* Le pattern https://en.wikipedia.org/wiki/Service_locator_pattern[Service Locator] qui via l'utilisation d'un registrer permet de retourver des implémentations correspondant à des contrats.
* Le pattern https://en.wikipedia.org/wiki/Dependency_injection[Dependancy injection] qui permet de passer une dépendance à un object dépendant.

La suite de l'article va se concentrer sur le troisième pattern, Depenceny Injection. Factory est un pattern trop simplice pour permettre de résoudre les dépendances à lui seul et Service Locator est devenu au fil du temps un anti-pattern (notamment parce qu'il crée de l'ahérence alors que c'est l'inverse que l'ont veut).


== StructureMap en action !

Il existe de nombreuse bibliothèque dédiée à l'IoC. Sincérement il n'y a pas de mauvais choix même si j'ai tendance à déconseiller celle de Microsoft (https://github.com/unitycontainer/unity[Unity]) qui est à la traine par rapport à la concurrence. Pour ma part j'ai longtemps utilisé Ninject pour son côté _"Simple & Straightforward"_, très éfficace en développement bien qu'un peu lent à l'execution il faut l'admettre. Dernièrement j'ai décidé de changer et je me suis mis sur StructureMap, un container historique (le premier en C#) qui embarque d'innombrables capacités pour un niveau de performance très correct. C'est un bon compromis entre capacité et puissance et depuis la version 3 il ont l'équipe à fait un gros travail pour se rapporcher de l'approche de Ninject. De plus il est en développement actif depuis presque 10 ans, il dispose d'une documentation riche et complète et est à l'heure ou j'écris le seul à disposer d'un support pour DNX.

Pour installer le package StructureMap il suffit d'ajouter le package Nuget via la commande :

----
Install-Package StructureMap
----

La première classe qui va nous intéresser est Container. C'est l'élément centrale de la librairie. Elle va nous permettre de définir les dépendances à résoudres, leur façon d'être résolut et leur récupération.
Pour définir une dépendance il nous faut un contract. Pour les besoins de l'article je vais en définir deux :

[source,csharp]
----
public interface IController
{
    void Action();
}
----

Le premier contrat est un controlleur qui réalise une action.

[source,csharp]
----
public interface ILogger
{
    void Information(string message);
}
----

Le second définit un logger qui va tracer un message d'information. Son implémentation est la suivante :

[source,csharp]
----
public class MyLogger
{
    public void Information(string message)
    {
        Console.WriteLine(message);
    }
}
----

Pour résoudre cette dépendance via le container il faut la définir. La classe possède un constructeur acceptant en paramètre une action qui expose un object de configuration. Cette object permet de définir les liaisons entre contrat et implémentation à l'aide des méthodes For<T> et Use<T> :

[source,csharp]
----
var container = new Container(configuration =>
{
	configuration.For<ILogger>().Use<Logger>();
});
----

Ces deux méthodes disposent d'une surcharge qui permet de passer en paramètre des object Type. Le résultat est le même mais syntaxiquement c'est plus lourd à lire. Il lié le contrat à une implémentation il existe aussi la méthode Add<T>, ce code fonctionne donc aussi :

[source,csharp]
----
var container = new Container(configuration =>
{
	configuration.For<ILogger>().Add<Logger>();
});
----

NOTE: Il existe une différenciation très nette entre les deux méthode. Add<T> permet d'ajouter une implémentation alors que Use<T> définit l'implementation comme strictement à utiliser. En conséquence lors que vous utilisez Use<T> c'est toujours la dernière liaison à une implémentation qui l'emporte.

La dépendance est à présent définit. Le code ne contient pas de logique de création des implémentations c'est donc l'instance de la class Container qui va donc les construire pour nous. Il est possible de les récupérer en appelant la méthode GetInstance<T>() :


[source,csharp]
----
var logger = container.GetInstance<ILogger>();
----

WARNING: Attention, la méthode GetInstance<T> peut très bien accepter des types implémentés sans que cela ne pose de problèmes. Cependant en faisant ça il y a une rupture avec le principe SOLID d'inversion de dépendance. N'oubliez pas : Il faut dépendre des abstractions, pas des implémentations.



== Mise en place dans WebApi




== IoC best practices

