= Inverser le contrôle avec StructueMap !
:hp-image: introduction-a-angular2.png
:published_at: 2015-11-26
:hp-tags: C#, IoC, StructureMap


L'inversion de contrôle (aka *IoC*) est un pattron d'architecture permettant de casser les adhérenses entre les dépendances. Ce découplage permet au dépendances de haut niveau de ne plus reposer directement sur celle de bas niveau et de passer par une couche d'abstration. L'objectif est d'améliorer la modularité des applications afin de faciliter les étapes de maintenance et d'évolution.


== Pourquoi ce pattern ?

Avant de montrer la mise en place de l'inversion de contrôle il est préférable d'expliquer comment on en est arrivé là !

Le problème de départ est assez simple en réalité. Si on a une application développée en couche et que l'ont fait reposer chaqu'une d'elle sur une autre de plus bas niveau, que va-t-il se passer si par la suite on veut changer, modifier, supprimer la couche la plus basse ? Le problème est là, il va falloir modifier la couche de plus haut niveau pour l'adapter en conséquence. Il est d'ailleurs fort probable que cela déclencher des modification en cascade sur toutes les couches haut niveau.

Avec l'inversion de contrôle on va plutôt faire reposer chaque couche sur une abstraction afin de passer de ça :

[Schéma]

A ça :

[Schéma]

La différence est suptile mais importante. Dans le second shémas, changer les couches concrêtes de mon application n'entraine pas de problèmes de structure, tout compilera. Mieux encore, le développement de l'application peut être abstrait et n'avoir aucunes connaissances du fonctionnement bas niveau. Plus fort, je peux définir des abstractions utilisés par les couches de bas niveau qui sont implémentées en haut niveau. Un autre intéressant, les test unitaires deviennent beaucoup plus simple et pertinent car les dépendances ne rentre plus en compte dans l'étape de validation.

Au final en utilisant l'inversion de contrôle, votre application va devenir plus modulaire, souple, maintenable, évolutive et testable.

NOTE: L'inversion de contrôle permet aussi de respecter un des principes majeurs de https://en.wikipedia.org/wiki/SOLID_(object-oriented_design)[SOLID] : l'inversion des dépendances. Ce principe définit qu'il faut toujours dépendre des abstractions et non des implémentations. Les principes SOLID sont considérer par beaucoup comme les _"Best Pratices"_ de la POO. Ils permettent d'avoir un développement éfficace et fiable.

Parmis les manières les plus courrante de mettre en place l'IoC, il existe :

* Le pattern https://en.wikipedia.org/wiki/Factory_(object-oriented_programming)[Factory] qui permet de délégué la création d'instance. Une approche rudimentaire mais qui a le mérite d'être simple dans sa mise en place.
* Le pattern https://en.wikipedia.org/wiki/Service_locator_pattern[Service Locator] qui via l'utilisation d'un registrer permet de retourver des implémentations correspondant à des contrats.
* Le pattern https://en.wikipedia.org/wiki/Dependency_injection[Dependancy injection] qui permet de passer une dépendance à un object dépendant.

La suite de l'article va se concentrer sur le troisième pattern, Depenceny Injection. Factory est un pattern trop simplice pour permettre de résoudre les dépendances à lui seul et Service Locator est devenu au fil du temps un anti-pattern (notamment parce qu'il crée de l'ahérence alors que c'est l'inverse que l'ont veut).


== StructureMap en action !

Il existe de nombreuse bibliothèque dédiée à l'IoC. Sincérement il n'y a pas de mauvais choix même si j'ai tendance à déconseiller celle de Microsoft (https://github.com/unitycontainer/unity[Unity]) qui est à la traine par rapport à la concurrence. Pour ma part j'ai longtemps utilisé Ninject pour son côté _"Simple & Straightforward"_, très éfficace en développement bien qu'un peu lent à l'execution il faut l'admettre. Dernièrement j'ai décidé de changer et je me suis mis sur StructureMap, un container historique (le premier en C#) qui embarque d'innombrables capacités pour un niveau de performance très correct. C'est un bon compromis entre capacité et puissance et depuis la version 3 il ont l'équipe à fait un gros travail pour se rapporcher de l'approche de Ninject. De plus il est en développement actif depuis presque 10 ans, il dispose d'une documentation riche et complète et est à l'heure ou j'écris le seul à disposer d'un support pour DNX

