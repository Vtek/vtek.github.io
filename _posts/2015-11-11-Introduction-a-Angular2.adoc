= Introduction à Angular2 !
:hp-image: introduction-a-angular2.png

:hp-tags: Angular2, TypeScript


L'annonce d'*Angular2* l'année dernière à la _ng-europe_ à fait couler beaucoup d'encre. Cette nouvelle version change complétement le framework, a tel point que l'on peut se demander si la librairie ne devrait pas s'appeller autrement. Dernièrement j'ai eu un peu de temps pour faire de la veille et ça faisait un moment que je voulais voir ce que cette version donne. Je vous propose donc un petit exemple !


== Rest API

Afin de gagner du temps, j'ai créé un Repo sur *Github* contenant une API Rest très simple à utiliser. Commencez par récupérer le projet ici :

https://github.com/Vtek/BlogIntroductionAngular2

L'Api tourne avec *node.js* (vous trouverez le runtime https://nodejs.org[ici]), et nécessite la CLI *TypeScript*. Il faut l'installer globalement via npm :

----
$ npm install -g typescript
----

TypeScript utilise des fichiers de définitions. Pour les gérer éfficacement j'utilise la CLI *tsd* :

----
$ npm install -g tsd
----

Pour compiler les fichiers TypeScript, mettez vous à la racine du projet et tapez les trois commandes suivantes :

----
$ npm install
$ tsd install
$ tsc
----

Si tout va bien l'API démarre via la commande :

----
$ npm start
----

Le serveur écoute sur le port 3000 et si vous attaquez l'url http://localhost:3000/user, vous devriez obtenir le *JSON* suivant en réponse :

++++
<iframe width="100%" height="150" src="//jsfiddle.net/Vtek/5vc4fvgx/embedded/" allowfullscreen="allowfullscreen" frameborder="0"></iframe>
++++

== Angular2 et les services

Si vous avez déjà fait de l'Angular, vous connaissez très certainement les _services_. C'est une des notions qui a été conservé dans la version 2 et nous allons en utiliser un pour consommer notre Rest API. Pour commencer, ajoutez un répertoire services dans :
----
public/javascripts/app
----
et ajoutez y un fichier _user.ts_ et un _user.service.ts_. Le fichier user.ts contient le code suivant :

++++
<iframe width="100%" height="120" src="//jsfiddle.net/Vtek/m5hp41ot/embedded/" allowfullscreen="allowfullscreen" frameborder="0"></iframe>
++++

Cette classe définit un object de données correspondant au JSON qui est renvoyé par l'API. Le fichier _user.service.ts_ aura pour structure :

++++
<iframe width="100%" height="200" src="//jsfiddle.net/Vtek/s2jgLa0v/embedded/" allowfullscreen="allowfullscreen" frameborder="0"></iframe>
++++

La méthode _getUser()_ permettera d'obtenir les données. Pour consommer l'API Rest il existe le module *Http*. Celui ci vous permez d'attaquer les services web via les principaux verbes Http (Get, Post, Put, Delete...). Pour l'utiliser il faut au préalable en connaitre la définition du module. De plus il faut que votre service puisse utiliser la classe User. Dans votre code source, avant l'export de la classe _UserService_ il faut donc ajouter les imports :

++++
<iframe width="100%" height="90" src="//jsfiddle.net/Vtek/aco04tn1/2/embedded/" allowfullscreen="allowfullscreen" frameborder="0"></iframe>
++++

Pour manipuler l'objet Http, ajoutez un attribut de classe au dessus du constructeur :

++++
<iframe width="100%" height="80" src="//jsfiddle.net/Vtek/Lu87cq26/embedded/" allowfullscreen="allowfullscreen" frameborder="0"></iframe>
++++

Dans getUsers() il est maintenant possible d'utiliser la référence pour faire notre appel à l'API :

++++
<iframe width="100%" height="100" src="//jsfiddle.net/Vtek/t6fha4zf/embedded/" allowfullscreen="allowfullscreen" frameborder="0"></iframe>
++++

La méthode get est utilisé pour faire un appel Http Get sur l'url http://localhost:3000/user. C'est un code fluent (https://fr.wikipedia.org/wiki/D%C3%A9signation_cha%C3%AEn%C3%A9e[Désignation chaînée]), il faut donc chainer sur la méthode map() qui va s'occuper de transcrire le JSON en objet de type User. Pour le faire on utilise une fonction fléchée (https://developer.mozilla.org/fr/docs/Web/JavaScript/Reference/Fonctions/Fonctions_fl%C3%A9ch%C3%A9es[Arrow function]) qui renvoie le résultat de la convertion.

NOTE: Les fonctions fléchées sont normalisées dans *ES6*. Elles sont utilisées depuis longtemps en programmation et on les retrouvent souvent sous le nom d'*Expression Lambda*. Cette dénomination vient du travail d'_Alonzo Church_ qui est l'inventeur de ce concept (https://fr.wikipedia.org/wiki/Lambda-calcul[λ-calcul]). Il est possible de les utiliser dans beaucoup de langages, notamment *C#*, *Lisp*, *Python* et même *C++* depuis la version 11 !

Notre service est quasiment finit, mais il manque une partie importante du code : l'instantiation de la classe Http. Pour le faire on va se dispenser du mot clé new car Angular utilise depuis toujours un concept fort et structurant : l'injection de dépendances. Je ne vais pas trop insister sur l'injection, cela mériterais un article entier sur le sujet (j'aborderais surement le sujet dans un billet, en attendant si vous êtes intéresser voir trouverez des infomations https://en.wikipedia.org/wiki/Dependency_injection[ici], https://en.wikipedia.org/wiki/Dependency_inversion_principle[ici] ou encore https://en.wikipedia.org/wiki/Inversion_of_control[ici])

Deux points sont important à noter niveau dépendances sur ce service :

* La classe Http est une dépendance nécessaire au bon fonctionnement du service.
* Le service en lui même est une dépendance qu'il faudra injecter.

Il va donc falloir utiliser des annotations pour gérer ces deux points.

NOTE: Les annotations sont des méta-données qui servent à décorer une classe, un paramètre ou encore une méthode. Cela permet de donner des aspects sans avoir à implémenter du code ou de la configuration sans dépendance à un fichier.

Commencez par importer les annotations dédiés à l'injection :

++++
<iframe width="100%" height="80" src="//jsfiddle.net/Vtek/e6y9jbdk/embedded/" allowfullscreen="allowfullscreen" frameborder="0"></iframe>
++++

L'annotation Injectable va permettre de décorer la classe pour qu'elle puisse être injecter, Inject qu'à lui permet de précider l'injection direct d'une dépendance. Les annotations doivent être préfixé par un *@* et préceder l'élement décorer.
Pour rendre la classe injectable il faut donc écrire :

++++
<iframe width="100%" height="120" src="//jsfiddle.net/Vtek/g8ho9br1/embedded/" allowfullscreen="allowfullscreen" frameborder="0"></iframe>
++++

Et pour injecter une instance d'Http, il faut le faire via le constructeur de la classe en décorant le paramètre d'entrée :

++++
<iframe width="100%" height="100" src="//jsfiddle.net/Vtek/kubhg4g1/embedded/" allowfullscreen="allowfullscreen" frameborder="0"></iframe>
++++

A ce stade le service utilisateur est terminé. Si vous avez bien suivi toutes les étapes vous devriez avoir le code suivant :

++++
<iframe width="100%" height="380" src="//jsfiddle.net/Vtek/Lnpy178y/embedded/" allowfullscreen="allowfullscreen" frameborder="0"></iframe>
++++

TIP: Vous avez surement fait attention à la ligne en commentaire tout en haut du code source. C'est la référence au fichier de définitions qui permet à votre IDE de faire l'auto-complétion en TypeScript. Ici la CLI tsd à centraliser l'ensemble des références dans un fichier tsd.d.ts. Il vous suffit ensuite d'ajouter cette référence dans n'importe quel fichier TypeScript pour accéder à l'ensemble de la complétion. C'est plutôt pratique, mais attention à ne pas mélanger l'utilisation des bibliothèques clients et serveurs dans votre code quand vous faite du node.js !

== Les composants
Angular2 a enterré plusieurs concepts important du framework. Les deux principaux pour moi sont le Scope et le Controller. Il est possible de trouver une explication logique a cette suppression. Quant on développait un controlleur Angular avec la première version il y avait une ambiguité entre les pattern https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93controller[MVC] et https://en.wikipedia.org/wiki/Model_View_ViewModel[MVVM]. D'un côté le controlleur traitait des actions mais d'un autre on utilisait le Scope pour faire le binding two way. Malheureusement le mélange de ces deux concepts créer pas mal de confusion et même si il est possible de les faire cohabiter, le mieux reste encore de les séparer clairement. Dans Angular2 plus d'ambiguité, nous avons à disposition les Components et on peut dire qu'il fonctionne comme des ViewModels. Certains ne seront peut-être pas d'accord avec mon analyse, mais on va dire que ce point de vue n'engage que moi ;)

Afin de rester bien organiser, ajoutez un répertoire components toujours dans :
----
public/javascripts/app
----
et ajoutez y un fichier _user.component.ts_ et un _user.component.html_. Le fichier .html correspondra au template utilisé par le compostant. L'idée est de partir sur une liste d'utilisateur
