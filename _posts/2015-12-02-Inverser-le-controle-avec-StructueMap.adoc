= Inverser le contrôle avec StructueMap !
:hp-image: introduction-a-angular2.png
:published_at: 2015-12-02
:hp-tags: C#, IoC, StructureMap


L'inversion de contrôle (aka *IoC*) est un pattron d'architecture permettant de casser les adhérenses entre les dépendances. Ce découplage permet au dépendances de haut niveau de ne plus reposer directement sur celle de bas niveau et de passer par une couche d'abstration. L'objectif est d'améliorer la modularité des applications afin de faciliter les étapes de maintenance et d'évolution.


== Pourquoi ce pattern ?

Avant de montrer la mise en place de l'inversion de contrôle il est préférable d'expliquer comment on en est arrivé là !

Le problème de départ est assez simple en réalité. Si on a une application développée en couche et que l'ont fait reposer chaqu'une d'elle sur une autre de plus bas niveau, que va-t-il se passer si par la suite on veut changer, modifier, supprimer la couche la plus basse ? Le problème est là, il va falloir modifier la couche de plus haut niveau pour l'adapter en conséquence. Il est d'ailleurs fort probable que cela déclencher des modification en cascade sur toutes les couches haut niveau.

Avec l'inversion de contrôle on va plutôt faire reposer chaque couche sur une abstraction afin de passer de ça :

[Schéma]

A ça :

[Schéma]

La différence est suptile mais importante. Dans le second shémas, changer les couches concrêtes de mon application n'entraine pas de problèmes de structure, tout compilera. Mieux encore, le développement de l'application peut être abstrait et n'avoir aucunes connaissances du fonctionnement bas niveau. Plus fort, je peux définir des abstractions utilisés par les couches de bas niveau qui sont implémentées en haut niveau. Un autre intéressant, les test unitaires deviennent beaucoup plus simple et pertinent car les dépendances ne rentre plus en compte dans l'étape de validation.

Au final en utilisant l'inversion de contrôle, votre application va devenir plus modulaire, souple, maintenable, évolutive et testable.

NOTE: L'inversion de contrôle permet aussi de respecter un des principes majeurs de https://en.wikipedia.org/wiki/SOLID_(object-oriented_design)[SOLID] : l'inversion des dépendances. Ce principe définit qu'il faut toujours dépendre des abstractions et non des implémentations. Les principes SOLID sont considérer par beaucoup comme les _"Best Pratices"_ de la POO. Ils permettent d'avoir un développement éfficace et fiable.

Parmis les manières les plus courrante de mettre en place l'IoC, il existe :

* Le pattern https://en.wikipedia.org/wiki/Factory_(object-oriented_programming)[Factory] qui permet de délégué la création d'instance. Une approche rudimentaire mais qui a le mérite d'être simple dans sa mise en place.
* Le pattern https://en.wikipedia.org/wiki/Service_locator_pattern[Service Locator] qui via l'utilisation d'un registrer permet de retourver des implémentations correspondant à des contrats.
* Le pattern https://en.wikipedia.org/wiki/Dependency_injection[Dependancy injection] qui permet de passer une dépendance à un object dépendant.

La suite de l'article va se concentrer sur le troisième pattern, Depenceny Injection. Factory est un pattern trop simplice pour permettre de résoudre les dépendances à lui seul et Service Locator est devenu au fil du temps un anti-pattern (notamment parce qu'il crée de l'ahérence alors que c'est l'inverse que l'ont veut).


== StructureMap en action : les bases !

Il existe de nombreuse bibliothèque dédiée à l'IoC. Sincérement il n'y a pas de mauvais choix même si j'ai tendance à déconseiller celle de Microsoft (https://github.com/unitycontainer/unity[Unity]) qui est à la traine par rapport à la concurrence. Pour ma part j'ai longtemps utilisé Ninject pour son côté _"Simple & Straightforward"_, très éfficace en développement bien qu'un peu lent à l'execution il faut l'admettre. Dernièrement j'ai décidé de changer et je me suis mis sur StructureMap, un container historique (le premier en C#) qui embarque d'innombrables capacités pour un niveau de performance très correct. C'est un bon compromis entre capacité et puissance et depuis la version 3 l'équipe à fait un gros travail pour se rapporcher de l'approche de Ninject. De plus il est en développement actif depuis presque 10 ans, il dispose d'une documentation riche et complète et est le premier à disposer d'un support pour DNX.

Pour installer le package StructureMap il suffit d'ajouter le package Nuget via la commande :

----
Install-Package StructureMap
----

La première classe qui va nous intéresser est Container. C'est l'élément centrale de la librairie. Elle va nous permettre de définir les dépendances à résoudres, leur façon d'être résolut et leur récupération.
Pour définir une dépendance il nous faut un contract. Pour les besoins de l'article je vais en définir un :

[source,csharp]
----
public interface ILogger
{
	void Information(string message);
}
----

L'interface correspond à un logger qui va tracer un message d'information. Son implémentation est la suivante :

[source,csharp]
----
public class ConsoleLogger : ILogger
{
	public void Information(string message)
	{
		Console.WriteLine(message);
	}
}
----

Pour résoudre cette dépendance via le container il faut la définir. La classe possède un constructeur acceptant en paramètre une action qui expose un object de configuration. Cette object permet de définir les liaisons entre contrat et implémentation à l'aide des méthodes For<T> et Use<T> :

[source,csharp]
----
var container = new Container(configuration =>
{
	configuration.For<ILogger>().Use<ConsoleLogger>();
});
----

Ces deux méthodes disposent d'une surcharge qui permet de passer en paramètre des object Type. Le résultat est le même mais syntaxiquement c'est plus lourd à lire. Il lié le contrat à une implémentation il existe aussi la méthode Add<T>, ce code fonctionne donc aussi :

[source,csharp]
----
configuration.For<ILogger>().Add<Logger>();
----

NOTE: Il existe une différenciation très nette entre les deux méthode. Add<T> permet d'ajouter une implémentation alors que Use<T> définit l'implementation comme strictement à utiliser. En conséquence lors que vous utilisez Use<T> c'est toujours la dernière liaison à une implémentation qui l'emporte.

Parfois il est nécessaire de définir comment le Container va créer l'instance, dans se cas il est possible d'utilise une surcharge de la méthode Use qui accept en paramètre une Function qui a en paramètre le context du containeret qui retourne une instance correspondant au contrat :

[source,csharp]
----
configuration.For<ILogger>().Use("Logger instance creation", (x) =>
{
	return new ConsoleLogger();
});
----

La dépendance est à présent définit. Le code ne contient pas de logique de création des implémentations c'est donc l'instance de la class Container qui va donc les construire pour nous. Il est possible de les récupérer en appelant la méthode GetInstance<T>() :


[source,csharp]
----
var logger = container.GetInstance<ILogger>();
----

WARNING: Attention, la méthode GetInstance<T> peut très bien accepter des types implémentés sans que cela ne pose de problèmes. Cependant en faisant ça il y a une rupture avec le principe SOLID d'inversion de dépendance. N'oubliez pas : Il faut dépendre des abstractions, pas des implémentations.

Si une dépendance n'est pas définit et que l'ont souhaite la résoudre, l'instance de Container léve une Exception de configuration. Il peut y avoir des cas où l'ont ne sait pas si une liaison est établie entre un contrat et une implémentation. Dans ce cas il vaut mieux utiliser la méthode TryGetInstance<T> et tester si l'instance est retournée est null, c'est plus optimisé que de traiter le cas avec un bloc try catch :

[source,csharp]
----
//Aucune implémentation de IDisposable n'est configurés actuellement
var disposable = container.GetInstance<IDisposable>();
Console.WriteLine(disposable == null);//print True
----

La méthode Add<T> permettant de définir plusieurs implémentation d'un même contrat, il existe une méthode GetAllInstances<T>() qui renvoie l'ensemble des implémentations correspondante. Si on rajoute une nouvelle implémentation de ILogger :

[source,csharp]
----
public class FileLogger : ILogger
{
	public void Information(string message)
	{
		File.WriteAllText("log.txt", message);
	}
}
----

Et qu'on l'ajoute les deux implémentations dans la configuration :

[source,csharp]
----
configuration.For<ILogger>().Add<ConsoleLogger>();
configuration.For<ILogger>().Add<FileLogger>();
----

L'appel à la méthode renverra une instance de IEnumerable<ILogger> :

[source,csharp]
----
var loggers = container.GetAllInstances<ILogger>();
Console.WriteLine(loggers.Count() == 2);//print True
----

A ce stade vous avez les bases pour résoudre des dépendances. Cependant l'utilisation actuelle du Container correspond à peu de chose prêt au pattern ServiceLocator. On aurait aussi pu faire une Factory pour gérer la création d'instance. Il est donc temps de s'intéresser à l'injection des dépendances.

== Injection

Pour injecter les dépendances il nous faut une classse plus haut niveau qui repose sur le contrat établit dans ILogger. Pour continuer avec un cas simple prenons l'exemple d'un controlleur qui, lors de l'éxecution d'une action, trace une information via le logger. Si l'ont veut casser l'adhérence il faut passer la dépendance implémentant ILogger via le constructeur :

[source,csharp]
----
public class Controller
{
	private ILogger _logger;

	public Controller(ILogger logger)
	{
		_logger = logger;
	}

	public void Action()
	{
		this._logger.Information("Hello from action !");
	}
}
----

Après avoir configurer le Container pour lié une des deux implémentations de ILogger, il est possible de récupérer une instance de la classe Controller via la méthode GetInstance<T>() :


[source,csharp]
----
var container = new Container(configuration =>
{
	configuration.For<ILogger>().Use<ConsoleLogger>();
});

var controller = container.GetInstance<Controller>();
controller.Action();// print "Hello from action !"
----

J'en vois déjà qui vont me répondre que j'ai mis un *Warning* plus haut concernant l'appel de GetInstance<T> sans utiliser une interface ! En réalité dans ce cas les choses sont différentes car Controller n'est pas une dépandance mais un dépendent. La résolution est donc conforme au principe d'inversion de dépendance. Cette manière de procéder est une des plus couramment utilisé dans le monde .Net (on l'a retrouve sous la forme de DependencyResolver dans les frameworks Microsoft).

StructureMap offre aussi la possibilité d'injecter les dépendances par inspection des propriétés plutôt que par le constructeur. C'est une alternative intéressante et facile à mettre en oeuvre. Déjà cela permet de réduire le code de la classe Controller à :

[source,csharp]
----
public class Controller
{
	public ILogger Logger { get; set; }

	public void Action()
	{
		this.Logger.Information("Hello from action !");
	}
}
----

Pour inspecter il existe une premier solution. En déclaration la liaison entre un contrat et son implémentation dans la configuration, une méthode Setter permet de spécifier pour quel type la une propriété inspecter peut êtere injecter : 

[source,csharp]
----
configuration.For<ILogger>().Use<ConsoleLogger>().Setter<ILogger>();
----

La méthode Setter<T> dispose d'une surcharge qui permet d'injecter à condition que le nom de la propriété match avec celui passé en argument :

[source,csharp]
----
configuration.For<ILogger>().Use<ConsoleLogger>().Setter<ILogger>("Logger");
----

NOTE: Cette surcharge peut s'avérer pratique, mais attention au renommage, on a vite fait d'oublier d'aller modifier la configuration du Container !

La deuxième solution pour mettre en place l'injection par propriété est de définir des conventions dans le registre des Policies du Container. Pour cela les développeurs de StructureMap on tout prévu, il existe une méthode SetAllProperties qui attent en paramètre une action exposant une instance de la classe SetterConvention :

[source,csharp]
----
configuration.Policies.SetAllProperties(convention => {

});
----

Plusieurs possibilés sont offertes pour définir une convention. La plus simple est celle qui définit une éxigence de type stricte :

[source,csharp]
----
convention.OfType<ILogger>();
----

Une convention par namespace peut être établit, elle permet de déclencher l'injection de la dépendance uniquement sur les classe appartenant à ce namespace. Deux possibilité de déclaration,  Soit par nom :

[source,csharp]
----
convention.WithAnyTypeFromNamespace("MyNamespace");
----

Soit en utilisant le namespace d'un type :

[source,csharp]
----
convention.WithAnyTypeFromNamespaceContainingType<ILogger>();
----

Ces trois exemple de convention permettent de traiter pas mal de cas. La classe SetterConvention offre plusieurs autres possibilités pour customiser sa logique d'injection. Le mieux c'est de les essayer pour voir celle qui conviennent aux besoins.

Au niveau de l'injection des dépendances, nous avons vu les deux méthodes principalement utilisées. Il faut savoir que la méthode priviliégié par la plus part des développeurs est celle injectant les dépendances par constructeur. Cependant il existe de nombreux car ou l'insepection est indispensanble (par exemple pour injecter des dépendances dans des attributs), donc il ne faut pas non plus complétement écarter cette possibilité.

== Lifecycle

Depuis le départ laa création des instances a été complétement délégué 

== Best practices

