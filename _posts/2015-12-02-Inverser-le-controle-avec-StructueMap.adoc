= Inverser le contrôle avec StructueMap !
:hp-image: introduction-a-angular2.png
:published_at: 2015-12-02
:hp-tags: C#, IoC, StructureMap


L'inversion de contrôle (aka *IoC*) est un pattron d'architecture permettant de casser les adhérenses entre les dépendances. Ce découplage permet au dépendances de haut niveau de ne plus reposer directement sur celle de bas niveau et de passer par une couche d'abstration. L'objectif est d'améliorer la modularité des applications afin de faciliter les étapes de maintenance et d'évolution.


== Pourquoi ce pattern ?

Avant de montrer la mise en place de l'inversion de contrôle il est préférable d'expliquer comment on en est arrivé là !

Le problème de départ est assez simple en réalité. Si on a une application développée en couche et que l'ont fait reposer chaqu'une d'elle sur une autre de plus bas niveau, que va-t-il se passer si par la suite on veut changer, modifier, supprimer la couche la plus basse ? Le problème est là, il va falloir modifier la couche de plus haut niveau pour l'adapter en conséquence. Il est d'ailleurs fort probable que cela déclencher des modification en cascade sur toutes les couches haut niveau.

Avec l'inversion de contrôle on va plutôt faire reposer chaque couche sur une abstraction afin de passer de ça :

[Schéma]

A ça :

[Schéma]

La différence est suptile mais importante. Dans le second shémas, changer les couches concrêtes de mon application n'entraine pas de problèmes de structure, tout compilera. Mieux encore, le développement de l'application peut être abstrait et n'avoir aucunes connaissances du fonctionnement bas niveau. Plus fort, je peux définir des abstractions utilisés par les couches de bas niveau qui sont implémentées en haut niveau. Un autre intéressant, les test unitaires deviennent beaucoup plus simple et pertinent car les dépendances ne rentre plus en compte dans l'étape de validation.

Au final en utilisant l'inversion de contrôle, votre application va devenir plus modulaire, souple, maintenable, évolutive et testable.

NOTE: L'inversion de contrôle permet aussi de respecter un des principes majeurs de https://en.wikipedia.org/wiki/SOLID_(object-oriented_design)[SOLID] : l'inversion des dépendances. Ce principe définit qu'il faut toujours dépendre des abstractions et non des implémentations. Les principes SOLID sont considérer par beaucoup comme les _"Best Pratices"_ de la POO. Ils permettent d'avoir un développement éfficace et fiable.

Parmis les manières les plus courrante de mettre en place l'IoC, il existe :

* Le pattern https://en.wikipedia.org/wiki/Factory_(object-oriented_programming)[Factory] qui permet de délégué la création d'instance. Une approche rudimentaire mais qui a le mérite d'être simple dans sa mise en place.
* Le pattern https://en.wikipedia.org/wiki/Service_locator_pattern[Service Locator] qui via l'utilisation d'un registrer permet de retourver des implémentations correspondant à des contrats.
* Le pattern https://en.wikipedia.org/wiki/Dependency_injection[Dependancy injection] qui permet de passer une dépendance à un object dépendant.

La suite de l'article va se concentrer sur le troisième pattern, Depenceny Injection. Factory est un pattern trop simplice pour permettre de résoudre les dépendances à lui seul et Service Locator est devenu au fil du temps un anti-pattern (notamment parce qu'il crée de l'ahérence alors que c'est l'inverse que l'ont veut).


== StructureMap en action : les bases !

Il existe de nombreuse bibliothèque dédiée à l'IoC. Sincérement il n'y a pas de mauvais choix même si j'ai tendance à déconseiller celle de Microsoft (https://github.com/unitycontainer/unity[Unity]) qui est à la traine par rapport à la concurrence. Pour ma part j'ai longtemps utilisé Ninject pour son côté _"Simple & Straightforward"_, très éfficace en développement bien qu'un peu lent à l'execution il faut l'admettre. Dernièrement j'ai décidé de changer et je me suis mis sur StructureMap, un container historique (le premier en C#) qui embarque d'innombrables capacités pour un niveau de performance très correct. C'est un bon compromis entre capacité et puissance et depuis la version 3 l'équipe à fait un gros travail pour se rapporcher de l'approche de Ninject. De plus il est en développement actif depuis presque 10 ans, il dispose d'une documentation riche et complète et est le premier à disposer d'un support pour DNX.

Pour installer le package StructureMap il suffit d'ajouter le package Nuget via la commande :

----
Install-Package StructureMap
----

La première classe qui va nous intéresser est Container. C'est l'élément centrale de la librairie. Elle va nous permettre de définir les dépendances à résoudres, leur façon d'être résolut et leur récupération.
Pour définir une dépendance il nous faut un contract. Pour les besoins de l'article je vais en définir un :

[source,csharp]
----
public interface ILogger
{
	void Information(string message);
}
----

L'interface correspond à un logger qui va tracer un message d'information. Son implémentation est la suivante :

[source,csharp]
----
public class ConsoleLogger : ILogger
{
	public void Information(string message)
	{
		Console.WriteLine(message);
	}
}
----

Pour résoudre cette dépendance via le container il faut la définir. La classe possède un constructeur acceptant en paramètre une action qui expose un object de configuration. Cette object permet de définir les liaisons entre contrat et implémentation à l'aide des méthodes For<T> et Use<T> :

[source,csharp]
----
var container = new Container(configuration =>
{
	configuration.For<ILogger>().Use<ConsoleLogger>();
});
----

Ces deux méthodes disposent d'une surcharge qui permet de passer en paramètre des object Type. Le résultat est le même mais syntaxiquement c'est plus lourd à lire. Il lié le contrat à une implémentation il existe aussi la méthode Add<T>, ce code fonctionne donc aussi :

[source,csharp]
----
configuration.For<ILogger>().Add<Logger>();
----

NOTE: Il existe une différenciation très nette entre les deux méthode. Add<T> permet d'ajouter une implémentation alors que Use<T> définit l'implementation comme strictement à utiliser. En conséquence lors que vous utilisez Use<T> c'est toujours la dernière liaison à une implémentation qui l'emporte.

Parfois il est nécessaire de définir comment le Container va créer l'instance, dans se cas il est possible d'utilise une surcharge de la méthode Use qui accept en paramètre une Function qui a en paramètre le context du containeret qui retourne une instance correspondant au contrat :

[source,csharp]
----
configuration.For<ILogger>().Use("Logger instance creation", (x) =>
{
	return new ConsoleLogger();
});
----

La dépendance est à présent définit. Le code ne contient pas de logique de création des implémentations c'est donc l'instance de la class Container qui va donc les construire pour nous. Il est possible de les récupérer en appelant la méthode GetInstance<T>() :


[source,csharp]
----
var logger = container.GetInstance<ILogger>();
----

WARNING: Attention, la méthode GetInstance<T> peut très bien accepter des types implémentés sans que cela ne pose de problèmes. Cependant en faisant ça il y a une rupture avec le principe SOLID d'inversion de dépendance. N'oubliez pas : Il faut dépendre des abstractions, pas des implémentations.

Si une dépendance n'est pas définit et que l'ont souhaite la résoudre, l'instance de Container léve une Exception de configuration. Il peut y avoir des cas où l'ont ne sait pas si une liaison est établie entre un contrat et une implémentation. Dans ce cas il vaut mieux utiliser la méthode TryGetInstance<T> et tester si l'instance est retournée est null, c'est plus optimisé que de traiter le cas avec un bloc try catch :

[source,csharp]
----
//Aucune implémentation de IDisposable n'est configurés actuellement
var disposable = container.GetInstance<IDisposable>();
Console.WriteLine(disposable == null);//print True
----

La méthode Add<T> permettant de définir plusieurs implémentation d'un même contrat, il existe une méthode GetAllInstances<T>() qui renvoie l'ensemble des implémentations correspondante. Si on rajoute une nouvelle implémentation de ILogger :

[source,csharp]
----
public class FileLogger : ILogger
{
	public void Information(string message)
	{
		File.WriteAllText("log.txt", message);
	}
}
----

Et qu'on l'ajoute les deux implémentations dans la configuration :

[source,csharp]
----
configuration.For<ILogger>().Add<ConsoleLogger>();
configuration.For<ILogger>().Add<FileLogger>();
----

L'appel à la méthode renverra une instance de IEnumerable<ILogger> :

[source,csharp]
----
var loggers = container.GetAllInstances<ILogger>();
Console.WriteLine(loggers.Count() == 2);//print True
----

A ce stade vous avez les bases pour résoudre des dépendances. Cependant l'utilisation actuelle du Container correspond à peu de chose prêt au pattern ServiceLocator. On aurait aussi pu faire une Factory pour gérer la création d'instance. Il est donc temps de s'intéresser à l'injection des dépendances.

== Injection

Pour injecter les dépendances il nous faut une classse plus haut niveau qui repose sur le contrat établit dans ILogger. Pour continuer avec un cas simple prenons l'exemple d'un controlleur qui, lors de l'éxecution d'une action, trace une information via le logger. Si l'ont veut casser l'adhérence il faut passer la dépendance implémentant ILogger via le constructeur :

[source,csharp]
----
public class Controller
{
	private ILogger _logger;

	public Controller(ILogger logger)
	{
		_logger = logger;
	}

	public void Action()
	{
		this._logger.Information("Hello from action !");
	}
}
----

Après avoir configurer le Container pour lié une des deux implémentations de ILogger, il est possible de récupérer une instance de la classe Controller via la méthode GetInstance<T>() :


[source,csharp]
----
var container = new Container(configuration =>
{
	configuration.For<ILogger>().Use<ConsoleLogger>();
});

var controller = container.GetInstance<Controller>();
controller.Action();// print "Hello from action !"
----

J'en vois déjà qui vont me répondre que j'ai mis un *Warning* plus haut concernant l'appel de GetInstance<T> sans utiliser une interface ! En réalité dans ce cas les choses sont différentes car Controller n'est pas une dépandance mais un dépendent. La résolution est donc conforme au principe d'inversion de dépendance. Cette manière de procéder est une des plus couramment utilisé dans le monde .Net (on l'a retrouve sous la forme de DependencyResolver dans les frameworks Microsoft).

StructureMap offre aussi la possibilité d'injecter les dépendances par inspection des propriétés plutôt que par le constructeur. C'est une alternative intéressante et facile à mettre en oeuvre. Déjà cela permet de réduire le code de la classe Controller à :

[source,csharp]
----
public class Controller
{
	public ILogger Logger { get; set; }

	public void Action()
	{
		this.Logger.Information("Hello from action !");
	}
}
----

Par défaut StructureMap ne résoudera pas la dépendance en l'état. Dans la configuration il faut, lors de la liaison entre un contrat et son implémentation, utiliser la méthode Setter pour spécifier quelle type de dépendance sous jacente va être injecter : 

[source,csharp]
----
configuration.For<IController>().Use<Controller>().Setter<ILogger>().Is<ConsoleLogger>();
----

La méthode Setter<T> dispose d'une surcharge qui permet d'injecter à condition que le nom de la propriété match avec celui passé en argument :

[source,csharp]
----
configuration.For<IController>().Use<Controller>().Setter<ILogger>("Logger").Is<ConsoleLogger>();
----

NOTE: Cette surcharge peut s'avérer pratique, mais attention au renommage, on a vite fait d'oublier d'aller modifier la configuration du Container !

Une fois mise en place il suffit de demander à récupérer une instance d'une dépendance pour que celle ci soit automatiquement injecter avec celle sous-jacente :

[source,csharp]
----
//Avec Setter<T> il devient obligatoire de demander une instance correspondant à un contrat.
//IController doit donc être définit dans votre code pour que cela fonctionne
var controller = container.GetInstance<IController>();
controller.Action();// print "Hello from action !"
----

Cette première façon de faire est certes éfficace mais imaginez faire cela pour toutes les dépendances... ce n'est pas très élégant. En plus il devient compliquer de résoudre les dépendances sur des instances dépendant qu'on voudrait résoudre avec le container. Il existe donc une méthode plus éfficace pour mettre en place l'injection par propriété : Définir des conventions dans le registre des Policies du Container. Pour cela les développeurs de StructureMap on tout prévu, il existe une méthode SetAllProperties qui attent en paramètre une action exposant une instance de la classe SetterConvention :

[source,csharp]
----
configuration.Policies.SetAllProperties(convention => {

});
----

Plusieurs possibilés sont offertes pour définir une convention. La plus simple est celle qui définit une éxigence de type stricte :

[source,csharp]
----
convention.OfType<ILogger>();
----

Une convention par namespace peut être établit, elle permet de déclencher l'injection de la dépendance uniquement sur les Type appartenant à ce namespace. Deux possibilité de déclaration,  Soit par nom :

[source,csharp]
----
convention.WithAnyTypeFromNamespace("MyNamespace");
----

Soit en utilisant le namespace d'un type en particulier :

[source,csharp]
----
convention.WithAnyTypeFromNamespaceContainingType<ILogger>();
----

Ces trois exemples de convention permettent de traiter pas mal de cas. La classe SetterConvention offre plusieurs autres possibilités pour customiser sa logique d'injection. Le mieux c'est de les essayer pour voir celle qui conviennent aux besoins.

Sans s'en rendre compte, en utilisant les conventions, une nouvelle capacités du Container a été dévérouiller, le BuildUp ! Il est maintenant possible de se dispenser d'utiliser la méthode GetInstance<T>() pour obtenir une instance d'un dépendant avec ses dépendances injectées :

[source,csharp]
----
var controller = new Controller();
container.BuildUp(controller);
----

L'intérêt premier est qu'avec cette technique on va pouvoir injecter les dépendances d'une instance dont la création est faite par un tier. Mine de rien cela ouvre pas mal de possibilité et permet de s'interfacer avec d'autre Framework ou Api qui possède leur propre mécanique de création d'instance (On peut cité par exemple Asp.Net MVC avec les ControllerFactory). C'est aussi une façon de faire qui est plus proche de la théorie de l'inversion de contrôle car dans ce cas précis il n'y a plus aucun appel direct de résolution d'un dépendant, le Container se préoccupe de se qu'il sait faire de mieux, résoudres les dépendances !

Au niveau de la mécanique d'injection des dépendances nous avons vu les fondamentaux. Il faut savoir que la méthode priviliégié par la plus part des développeurs est celle injectant les dépendances par constructeur. Elle demande bien moins d'effort et évite d'avoir des propriétés publique manipulable par le premier venu. Cependant il existe de nombreux cas ou l'insepection par propriété est indispensanble (par exemple pour injecter des dépendances dans des attributs), donc il ne faut pas non plus complétement écarter cette possibilité. Personnellement j'utilise beaucoup l'injection par propriété car ça permet d'avoir une grande compacité de code en plus déviter de manipuler l'affectation des références à la main (je trouve que c'est plus clean sur ce point). Cependant quand je le fait je suis beaucoup plus stricte sur les règles de manipulation de ses instances. Il faut clairement que la responsabilité de leur manipulation soit faite uniquement par le dépendant, sinon c'est la porte ouvert à de nombreux problème.


== Lifecycle

Depuis le début de cette article la création des instances des dépendances a été complétement délégué à la classe Container. La grand question à présent est : Comment puis gérer le cycle de vie des instances au sein de mon container ?

StructureMap, comme tout les container IoC, met à disposition un ensemble de méthode et classe pour gérer cela. Par défaut lorsque l'ont ajouter une liaison entre un contrat et une implémentation, le container va définir leur cycle de vie à l'état Transient. Cela veut dire qu'à chaque fois qu'il résoudra une dépendance il créra une instance. Il est tout façon possible de mettre explicitement la dépendance dans le mode Transient :

[source,csharp]
----
configuration.For<ILogger>().Use<ConsoleLogger>().Transient();
----

Logiquement si l'on demande deux fois la dépendance, la référence est différente :

[source,csharp]
----
var logger = container.GetInstance<ILogger>();
var logger2 = container.GetInstance<ILogger>();
Console.WriteLine(logger == logger2);//print False
----

Un cas régulier dans le cycle de vie des objets c'est l'instance unique. Pour le faire on utilise la méthode Singleton :

[source,csharp]
----
configuration.For<ILogger>().Use<ConsoleLogger>().Singleton();
----

En conséquence le test de référence que l'on a fait précedement renvoie True :

[source,csharp]
----
var logger = container.GetInstance<ILogger>();
var logger2 = container.GetInstance<ILogger>();
Console.WriteLine(logger == logger2);//print True
----

Ces deux cas sont parmis les principaux que l'ont trouve dans le développement mais il en existe d'autre qui permettent de gérer la vie de l'instance sur un Thread ou encore dans un container encapsuler dans un scope temporaire (ContainerScoped, utiliser pour gérer notamment le cas de DNX)

Il existe une autre façon de déclarer un cycle de vie avec StructureMap. Dans la bibliothèque une interface ILifecycle permet d'implémenter facilement sont propre cycle de vie.

== Best practices

